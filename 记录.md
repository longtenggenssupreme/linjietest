## <font color=Red>记录</font>

## 2020-12-22 WebAppNet5添加 Delegate TestVoidDelegate
## 2020-12-22 WebAppNet5添加autofac的Autofac AOP 
1. Nuget引用Castle.Core，Autofac.Extras.DynamicProxy,
2. 动态异步 Castle.Core.AsyncInterceptor

## 2020-12-22 WebAppNet5添加Autofac 一对象多实例问题,例如：一个接口ITestA 2个实现TestA和TestF
1. 一个接口ITestA 2个实现TestA和TestF,
            //AController中使用测试，可以同时获取接口ITestA的2个实现TestA和TestF的实例，
            //然后可以使用TestA和TestF来调用对应的方法,
            //使用 public AController(ITestA testA, IEnumerable<ITestA> testAList, TestA testAA, TestF testFF, ITestC testC)
            //containerBuilder.RegisterSource(new AnyConcreteTypeNotAlreadyRegisteredSource(t => t.IsAssignableTo(typeof(ITestA))));
            //下面是对上面的扩展，其实内容是一样的
            containerBuilder.RegisterModule(new CustomModule());
2. IComponentContext 这个对象可以获取对应的接口服务，组件上下文，用于一接口多实现的使用一个接口ITestA 2个实现TestA和TestF,AController中使用测试 使用Index1测试
```
            //IComponentContext 这个对象可以获取对应的接口服务，组件上下文，
            //这是一接口多实现的使用，IComponentContext组件上下文，
            //用于一接口多实现的使用一个接口ITestA 2个实现TestA和TestF,AController中使用测试 使用Index1测试
            var componentCintext = contaier.Resolve<IComponentContext>();
            var testA1 = componentCintext.ResolveKeyed<ITestA>("TestA");
            testA1 = componentCintext.ResolveNamed<ITestA>("TestA");
            testA1.Show();
            var testF1 = componentCintext.ResolveKeyed<ITestA>("TestF");
            testF1 = componentCintext.ResolveKeyed<ITestA>("TestF");
            testF1.Show();
```

## 2020-12-22 WebAppNet5添加autofac的Autofac 配置文件 配置IOC 依赖注入 属性注入 
1. Nuget程序管理包添加引用<font color=blue> Autofac， Autofac.Configuration， Autofac.Extensions.DependencyInjection</font>
2. autofacconfig.json 内容如下，并设置 <font color=Red> 复制到输出目录--》始终复制 生成操作--》内容</font>
```
{
  "components": [
    {
      "type": "WebAppNet5.TestA,WebAppNet5",
      "services": [
        {
          "type": "WebAppNet5.ITestA,WebAppNet5"
        }
      ],
      "instanceScope": "per-dependency", //瞬态
      "injectProperty": true
    },
    {
      "type": "WebAppNet5.TestB,WebAppNet5",
      "services": [
        {
          "type": "WebAppNet5.ITestB,WebAppNet5"
        }
      ],
      "instanceScope": "single-instance",//单例
      "injectProperty": true
    },
    {
      "type": "WebAppNet5.TestC,WebAppNet5",
      "services": [
        {
          "type": "WebAppNet5.ITestC,WebAppNet5"
        }
      ],
      "instanceScope": "per-lifetime-scope", //作用域，选择项如：'single-instance', 'per-dependency' (the default), 'per-lifetime-scope', and 'per-request'.”
      "injectProperty": true
    }
  ]
}

```

## WebAppNet5添加autofac的生命周期和各种注入方式

## 2020-12-18 测试添加消除ifelse的内容

## 2020-12-17 测试HttpListener,测试HttpListenerWebSocket,测试Socket,测试Tcp,测试Udp
```
#region 将无连接数据报发送到指定的远程主机
            //IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());
            //IPEndPoint endPoint = new IPEndPoint(hostEntry.AddressList[3], 11000);
            //Socket s = new Socket(endPoint.Address.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
            //byte[] msg = Encoding.ASCII.GetBytes("This is a test");
            //Console.WriteLine("Sending data.");
            //// This call blocks.
            //s.SendTo(msg, endPoint);
            //s.Close();
            #endregion

            #region 从远程主机接收无连接的数据报

            // IPHostEntry hostEntry1 = Dns.GetHostEntry(Dns.GetHostName());
            //IPEndPoint endPoint1 = new IPEndPoint(hostEntry1.AddressList[3], 11000);
            //Socket s1 = new Socket(endPoint1.Address.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
            //// Creates an IPEndPoint to capture the identity of the sending host.
            //IPEndPoint sender = new IPEndPoint(IPAddress.Any, 0);
            //EndPoint senderRemote = (EndPoint)sender;
            //// Binding is required with ReceiveFrom calls.
            //s1.Bind(endPoint);

            //byte[] msg1 = new Byte[256];
            //Console.WriteLine("Waiting to receive datagrams from client...");
            //// This call blocks.
            //s1.ReceiveFrom(msg, ref senderRemote);
            //s1.Close();
            #endregion
```

## 2020-12-15 AspnetcoreRateLimit用作webapi 接口的访问限制，限制接口指定时间内的访问次数
1. AspnetcoreRateLimit用作webapi 接口的访问限制，限制接口指定时间内的访问次数，NuGet程序管理包添加AspNetCoreRateLimit引用
2. ConfigureServices中添加如下内容
```
 #region 添加使用限流服务AspNetCoreRateLimit
            services.AddMemoryCache();
            services.Configure<IpRateLimitOptions>(Configuration.GetSection("IpRateLimit"));
            services.AddSingleton<IIpPolicyStore, MemoryCacheIpPolicyStore>();
            services.AddSingleton<IRateLimitCounterStore, MemoryCacheRateLimitCounterStore>();
            services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();
            services.AddHttpContextAccessor();
            #endregion
```
3. Configure中添加如下内容
```
app.UseRouting();
//使用限流中间件
app.UseIpRateLimiting();
```
4. appsettings.json中添加如下内容
```
//下面的限流规则可以确保：含有 "*/home" 的 url 链接在1分钟周期内最多有5次访问。
  "IpRateLimit": {
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "RealIPHeader": "X-Real-IP",
    "ClientIdHeader": "X-ClientId",
    "HttpStatusCode": 429,
    "GeneralRules": [
      {
        "Endpoint": "*/home",
        "Period": "1m",
        "Limit": 5
      }
    ]
```

## 2020-12-15 RestSharp 是对restfull 风格接口的封装，可以用于webapi接口测试
1. 示例
```
 public static async void TestRestSharp()
        {
            await Task.Delay(TimeSpan.FromSeconds(3));
            //创建RestSharp的请求客户端以及设置基地址，该机地址是配合请求的资源地址一起使用的
            //RestSharp.RestClient restClient = new RestSharp.RestClient("http://+:5566");//http://localhost:5566
            RestClient restClient = new RestClient("http://localhost:5566");
            //创建请求信息以及请求的地址
            RestRequest restRequest = new RestRequest("/api/TestRestSharp", Method.GET);
            //restRequest.AddHeader("contentType", "application.json;charset=utf-8");
            //执行请求，获取返回的请求结果
            //var result = restClient.ExecuteAsync(restRequest).GetAwaiter().GetResult();
            var result = restClient.Execute<List<string>>(restRequest);

            restRequest = new RestRequest("/api/TestRestSharp/1", Method.GET);
            var result1 = restClient.Execute(restRequest);

            restRequest = new RestRequest("/api/TestRestSharp", Method.POST);
            restRequest.AddJsonBody("666666");
            var result2 = restClient.Execute(restRequest);

            restRequest = new RestRequest("/api/TestRestSharp/2", Method.PUT);
            restRequest.AddJsonBody("9999");
            var result3 = restClient.Execute(restRequest);

            restRequest = new RestRequest("/api/TestRestSharp/1", Method.DELETE);
            var result4 = restClient.Execute(restRequest);
            //if (result is not null)
            //{
            //    Console.WriteLine($"FeatureManage NET应用实现定时开关,启用");
            //}
            //else
            //{
            //    Console.WriteLine($"FeatureManage开关,关闭");
            //}
        }
```

## 2020-12-15 FeatureManage与 FeatureManage.Aspnetcore是开关的封装类库
```
1、public void ConfigureServices(IServiceCollection services)
     {
       //使用NuGet程序管理程序，添加Microsoft.FeatureManagement.AspNetCore
       services.AddFeatureManagement().AddFeatureFilter<TimeWindowFilter>();
     }
2、@*appsettings.json中配置 FeatureFilter<TimeWindowFilter>()过滤器 配置信息 "FeatureManagement": {
          "CustomeSwitch": {
            "EnabledFor": [
              {
                "Name": "TimeWindow",
                "Parameters": {
                  "Start": "12/16/2020 00:00:00 GMT",
                  "End": "12/30/2020 00:00:00 GMT"
                }
              }
            ]
          }
        },
            其中 CustomeSwitch 是feature标签要绑定的名称，根据该值是否显示标签信息的。
            如果不想显示feature标签，只需要设置 negate="true"
        *@
        <feature name="CustomeSwitch"><font color="red">这是.NET应用实现定时开关,使用addTagHelper标签feature 没有设置 negate="true",显示feature标签  </font></feature>
        @*设置 negate="true",不想显示feature标签 *@
        <feature name="CustomeSwitch" negate="true" ><font color="red">这是.NET应用实现定时开关,使用addTagHelper标签feature 设置 negate="true",不显示feature标签</font></feature>
```

## 2020-12-15 QuartZ的Cron表达式=》秒 分 时 天 月 星期 年(可选) 中间空格分割
```
cron表达式详解
　　Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式：

　　（1） Seconds Minutes Hours DayofMonth Month DayofWeek Year

　　（2）Seconds Minutes Hours DayofMonth Month DayofWeek

　　

　　一、结构

　　corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份

　　二、各字段的含义

 
字段	允许值	允许的特殊字符
秒（Seconds）	0~59的整数	, - * /    四个字符
分（Minutes）	0~59的整数	, - * /    四个字符
小时（Hours）	0~23的整数	, - * /    四个字符
日期（DayofMonth）	1~31的整数（但是你需要考虑你月的天数）	,- * ? / L W C     八个字符
月份（Month）	1~12的整数或者 JAN-DEC	, - * /    四个字符
星期（DayofWeek）	1~7的整数或者 SUN-SAT （1=SUN）	, - * ? / L C #     八个字符
年(可选，留空)（Year）	1970~2099	, - * /    四个字符
　　注意事项：

　　每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是：

　　（1）*：表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。

　　（2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 * ?, 其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。

　　（3）-：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 

　　（4）/：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. 

　　（5）,：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 

　　（6）L：表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 

　　（7）W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。

　　（8）LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 

　　（9）#:用于确定每个月第几个星期几，只能出现在DayofWeek域。例如在4#2，表示某月的第二个星期三。

　　三、常用表达式例子

　　（0）0/20 * * * * ?   表示每20秒 调整任务

　　（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务

　　（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业

　　（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作

　　（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点 

　　（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时 

　　（6）0 0 12 ? * WED    表示每个星期三中午12点 

　　（7）0 0 12 * * ?   每天中午12点触发 

　　（8）0 15 10 ? * *    每天上午10:15触发 

　　（9）0 15 10 * * ?     每天上午10:15触发 

　　（10）0 15 10 * * ? *    每天上午10:15触发 

　　（11）0 15 10 * * ? 2005    2005年的每天上午10:15触发 

　　（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发 

　　（13）0 0/5 14 * * ?    在每天下午2点到下午2:55期间的每5分钟触发 

　　（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 

　　（15）0 0-5 14 * * ?    在每天下午2点到下午2:05期间的每1分钟触发 

　　（16）0 10,44 14 ? 3 WED    每年三月的星期三的下午2:10和2:44触发 

　　（17）0 15 10 ? * MON-FRI    周一至周五的上午10:15触发 

　　（18）0 15 10 15 * ?    每月15日上午10:15触发 

　　（19）0 15 10 L * ?    每月最后一日的上午10:15触发 

　　（20）0 15 10 ? * 6L    每月的最后一个星期五上午10:15触发 

　　（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发 

　　（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发

　　注：

　　（1）有些子表达式能包含一些范围或列表

　　例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”

“*”字符代表所有可能的值

　　因此，“*”在子表达式（月）里表示每个月的含义，“*”在子表达式（天（星期））表示星期的每一天


　　“/”字符用来指定数值的增量 
　　例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟 
在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样


　　“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 
　　当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”

　　“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 
　　但是它在两个子表达式里的含义是不同的。 
　　在天（月）子表达式中，“L”表示一个月的最后一天 
　　在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT

　　如果在“L”前有具体的内容，它就具有其他的含义了

　　例如：“6L”表示这个月的倒数第６天，“FRIL”表示这个月的最一个星期五 
　　注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题
```

## 2020-12-15 Dotnet Core下的ChannelSystem.Threading.Channels
1. 逻辑上，Channel实际就是一个高效的、线程安全的队列，支持在生产者和消费者之间传递数据。
2. 利用Channel，通过发布和订阅，可以将生产者和消费者分开。生产者Producer负责接收请求，并写入Channel，
3. 而消费者Consumer为每个进入Channel的数据执行处理。
4. 这样做，一方面可以使生产者和消费者并行工作来提高性能，
5. 另一方面，可以通过创建更多的生产者或消费者来提高应用的吞吐量。

## 2020-12-14 WebAppNet5 添加Html自定义视图组件，可以加特性，以特性为准，否则使用类名去掉ViewComponent，即MyCustom，调用的时候使用的名称
使用视图组件  @await Component.InvokeAsync("CustomView", new { json = "哈哈，这是自定义视图组件2222" })

## 2020-12-11 WebAppNet5 添加Html自定义部分视图，可以加特性，以特性为准，否则使用类名去掉ViewComponent，即MyCustom，调用的时候使用的名称
使用部分视图 @await Html.PartialAsync("/Views/Haha/Index2.cshtml")

!["不显示图片时的alt"]("https://note.youdao.com/yws/res/272/WEBRESOURCE9d30a122d186506672c07ccad108b402","知识图谱")
#### 2020-12-11 WebAppNet5 添加Html ViewBag ViewData TempData传值

#### 2020-12-11 WebAppNet5 添加Razor的定义扩展标签和taghelper标签


#### 2020-12-10 WebAppNet5 添加NLog日志 添加NLog.Web.AspNetCore.dll
1. 在Program中添加NLog日志
```
 public static void Main(string[] args)
        {
            var log = NLogBuilder.ConfigureNLog("Config/nlog.config").GetCurrentClassLogger();
            try
            {
                log.Info("开启日志服务");
                CreateHostBuilder(args).Build().Run();
            }
            catch (System.Exception ex)
            {
                log.Error($"{ex}");
            }
            finally {
                log.Info("日志服务关闭");
                NLog.LogManager.Shutdown();
            }  
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
            //.ConfigureLogging(logbuild => logbuild.AddLog4Net("Config/log4net.config"))//log4net第一种使用方法
            .ConfigureWebHostDefaults(webBuilder =>
                {
                    //webBuilder.UseStartup<Startup>();
                    //多环境---启动类多环境 ====自动寻找指定程序集下对于的Startup类===StartupDemo
                    //webBuilder.UseStartup(System.Reflection.Assembly.GetExecutingAssembly().FullName);
                    //多环境---启动类中的方法多环境 Startup类===新添加 ConfigureDemoServices和ConfigureDemo，后缀Demo
                    webBuilder.UseStartup<Startup>();
                })
            .UseServiceProviderFactory(new AutofacServiceProviderFactory())//添加AutofacServiceProviderFactory依赖注入容器
             .ConfigureLogging(logging =>
             {
                 logging.ClearProviders();//清除其他的文件日志文件提供器
                 logging.SetMinimumLevel(LogLevel.Error);//Logging LogLevel设置 优先级 command > appsettings.json > 硬编码
             })
            .UseNLog();//依赖注入NLog日志组件 
```
2. 新建Config/nlog.config配置文件(注意一般名称小写nlog.config)，内容如下
```
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

	<targets>
		<target name="logfile" xsi:type="File" fileName="file.txt" />
		<target name="logconsole" xsi:type="Console" />
	</targets>

	<rules>
		<logger name="*" minlevel="Info" writeTo="logconsole" />
		<logger name="*" minlevel="Debug" writeTo="logfile" />
	</rules>
</nlog>
```
3. 修改nlog.config属性 复制到输出目录 -》 始终复制，生成操作 -》内容


#### 2020-12-10 WebAppNet5 添加Log4Net日志 添加Microsoft.Extensions.Logging.Log4Net.AspNetCore.dll
1. 在Configure中添加ILoggerFactory loggerFactory即可
``` public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            loggerFactory.AddLog4Net("log4net.config");//第二种使用方法
            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        } 
```
2. 在CreateHostBuilder中添加.ConfigureLogging(logbuild => logbuild.AddLog4Net("log4net.config"))//第一种使用方法
```
public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logbuild => logbuild.AddLog4Net("log4net.config"))//第一种使用方法
            .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                }).UseServiceProviderFactory(new AutofacServiceProviderFactory());//添加AutofacServiceProviderFactory依赖注入容器
```
3. 
#### 2020-12-10 WebAppNet5 添加AutofacServiceProviderFactory依赖注入容器
1. nuget 添加Autofac
2. Program中添加UseServiceProviderFactory(new AutofacServiceProviderFactory());//添加AutofacServiceProviderFactory依赖注入容器
3. 代码如下：
``` 
public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =>
                {
                    webBuilder.UseStartup<Startup>();
                }).UseServiceProviderFactory(new AutofacServiceProviderFactory());//添加AutofacServiceProviderFactory依赖注入容器
```
3. 3、
4.
4. 4、

#### 2020-12-3 自定义容器IOC(控制反转)，使用DI(依赖注入) 测试成功

#### 2020-12-3 添加自定义容器
![图片链接](地址,"标题")
[超链接](地址,"标题")

1. IOC 控制反转 以前是自己创建类的实例对象，现在有容器进行创建
2. DI 可以通过依赖注入的方式(构造函数，属性，方法)进行属性赋值
3. 存储容器创建的对象，使用哈希表来存储(哈希字典，hashset等，不建议使用List，一方面性能差，二来检索效率低)

#### 2020-12-2 添加lambda 表达式拼接
#### 2020-11-2 CommonTools文件夹下的ComLibs是常用的类库集合
#### 2020-12-2 Test文件夹下的ConsoleTest是测试常用的类库的测试程序
